import numpy as np
import os
import os.path as osp
from fcnet import *
import torch.nn as nn
from tqdm import tqdm
from data_loader import *
from utils import *


def eval(N, top):
    cnt = 0
    matched = []
    while cnt < data.cnt_val:
        x_test, y_test = data.next_val()
        x_test = torch.Tensor(x_test).to(device)
        y_test = torch.Tensor(y_test).to(device)
        cnt += len(y_test)
        result = N(x_test)
        _, predicts = result.sort(1)
        predicts = predicts[:,-top:].cpu().numpy()
        ground_truth = y_test.argmax(1).cpu().numpy()

        m = [True if ground_truth[j] in predicts[j] else False for j in range(ground_truth.__len__())]
        matched += m
    score = np.array(matched).sum() * 1.0 / data.cnt_val
    return score


def calc_train_score(N, top):
    _, predicts = out.sort(1)
    predicts = predicts[:,-top:]
    ground_truth = y.argmax(1)
    m = [True if ground_truth[j] in predicts[j] else False for j in range(ground_truth.__len__())]
    score_train = np.array(m).sum() * 1.0 / len(ground_truth)
    return score_train


if __name__ == '__main__':
    combined_data_path = osp.join(os.getcwd(), '..', 'train', 'data', 'combined_rn50')
    data_path = osp.join(os.getcwd(), '..', 'train', 'data', 'resnet50')
    checkpoint_dir = osp.join(os.getcwd(), '..', 'train', 'checkpoint') 
    create_folder(checkpoint_dir)
    create_folder(combined_data_path)

    total_steps = 100000
    print_step = 1000
    #save_step = 1000
    batch_size = 1000
    learning_rate = 1e-4
    in_dim = 2048
    out_dim = 9

    device = 'cpu'
    if torch.cuda.is_available():
        device = 'cuda'
    N = fcnet(batch_size, in_dim, [512, 128, 32], out_dim)
    N = N.to(device)
    data = DataLoader(batch_size, data_path, combined_data_path)
    cost_func = nn.BCELoss()
    optim = torch.optim.Adam(N.parameters(), lr=learning_rate)

    best_score = 0.0
    best_loss = float("Inf")

    for i in tqdm(range(total_steps)):
        x, y = data.next_batch() 
        x = torch.Tensor(x).to(device)
        y = torch.Tensor(y).to(device)
        out = N(x)
        loss = cost_func(out, y)
        loss.backward()
        optim.step()
        N.zero_grad()

        if i % print_step == 0:
            score = eval(N,1)           
            # Calculate training accuracy score to prevent overfit 

            score_train = calc_train_score(N, 1)
            print("Iters: {}  - Loss: {} - Accuracy Train: {} - Accuracy Test: {}".format(i, loss, score_train, score))

            if score > best_score and loss < best_loss:
                best_score = score
                best_loss = loss
                save_checkpoint(N, optim, score, loss, checkpoint_dir, "best.weight") 
