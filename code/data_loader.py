import numpy as np
import os.path
import json
import os.path as osp
import os


class DataLoader():
    def __init__(self, batch_size, data_path, combined_data_path, public_test=False):
        self.batch_size = batch_size
        self.data_path = data_path
        self.combined_data_path = combined_data_path

        if public_test == False:
            x_path = osp.join(self.combined_data_path, 'x_attributes.npy')
            y_path = osp.join(self.combined_data_path, 'y_attributes.npy')
            if not osp.exists(x_path) or not osp.exists(y_path):
                self._combine_data(public_test)
            self.x = np.load(x_path)
            self.y = np.load(y_path)

            self.cnt_total = len(self.y)
            self.cnt_val = int(self.cnt_total / 5.0) # Keep the ratio between train/test data split to be 80/20
            self.cnt_train = self.cnt_total - self.cnt_val

            self.pt_train_index = self.cnt_val
            self.permutation = np.random.permutation(self.cnt_total)
        else:
            x_path = osp.join(self.combined_data_path, 'x_attributes.npy')
            x_file_mapping = osp.join(self.combined_data_path, 'x_filenames.npy')
            if not osp.exists(x_path) or not osp.exists(x_file_mapping):
                self._combine_data(public_test)
            self.x = np.load(x_path)
            self.x_file_map = np.load(x_file_mapping)
            self.cnt_total = self.x.shape[0]
            self.cnt_test = self.cnt_total
            self.permutation = [i for i in range(self.cnt_total)]


        # Some variables determine the current data pointer index
        self.pt_test_index = 0
        self.pt_val_index = 0


    def _combine_data(self, public_test):
        xs = []
        ys = []
        x_file_mappings = []
        num_cls = 0
        if public_test == False:
            num_cls = len(os.listdir(self.data_path))
        for root, dirs, files in os.walk(self.data_path):
            for f in files:
                _f = osp.join(root, f)
                x = np.load(_f)
                xs.append(x)
                if public_test == False:
                    label = int(root.split('/')[-1])
                    y = self._to_one_hot(label, num_cls)
                    ys.append(y)
                else:
                    x_file_mappings.append(f)
        xs = np.asarray(xs)
        x_path = osp.join(self.combined_data_path, 'x_attributes.npy')
        np.save(x_path, xs)
        if public_test == False:
            ys = np.asarray(ys)
            y_path = osp.join(self.combined_data_path, 'y_attributes.npy')
            np.save(y_path, ys)
        else:
            x_file_mapping_path = osp.join(self.combined_data_path, 'x_filenames.npy')
            x_file_mappings = np.asarray(x_file_mappings)
            np.save(x_file_mapping_path, x_file_mappings)


    def _to_one_hot(self, y, num_cls):
        onehot = np.zeros(num_cls, dtype=np.uint8)   
        onehot[y-1] = 1
        return onehot


    def next_batch(self):
        start_index = self.pt_train_index
        end_index = start_index + self.batch_size
        if end_index > self.cnt_total: # May miss data at the end !!!
            index = self.permutation[start_index:]
            np.random.shuffle(self.permutation[self.cnt_val:self.cnt_total])
            start_index = self.cnt_val
            self.pt_train_index = self.cnt_val
            end_index = start_index + self.batch_size
            return self.x[index], self.y[index]
        index = self.permutation[start_index:end_index]
        self.pt_train_index = end_index
        return self.x[index], self.y[index]


    def next_val(self):
        start_index = self.pt_val_index
        end_index = start_index + self.batch_size
        if end_index > self.cnt_val:
            index = self.permutation[start_index:self.cnt_val]
            self.pt_val_index = 0
            return self.x[index], self.y[index]
        self.pt_val_index = end_index
        index = self.permutation[start_index:end_index]
        return self.x[index], self.y[index]
    
    
    def next_test(self):
        start_index = self.pt_test_index
        end_index = start_index + self.batch_size
        if end_index > self.cnt_test:
            index = self.permutation[start_index:self.cnt_test]
            self.pt_test_index = 0
            return self.x[index]
        self.pt_test_index = end_index
        index = self.permutation[start_index:end_index]
        return self.x[index]
